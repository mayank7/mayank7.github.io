<html><body bgcolor="#0099CC"><b><font color="#FFFFFF" face="Verdana, Arial, Helvetica, sans-serif">21. Does the minimum spanning tree of a graph give the shortest distance between any 2 specified nodes?<br><br><font color="�#000000�"><u>Answer:</u><br>No. The Minimal spanning tree assures that the total weight of the tree is kept at its minimum. But it doesn't mean that the distance between any two nodes involved in the minimum-spanning tree is minimum.</font><br><br>22. Which is the simplest file structure?<br><br><font color="�#000000�"><u>Answer:</u><br>(Sequential, Indexed, Random) Sequential is the simplest file structure.</font><br><br>23. Whether Linked List is linear or Non-linear data structure?<br><br><font color="�#000000�"><u>Answer:</u><br>According to Access strategies Linked list is a linear one. According to Storage Linked List is a Non-linear one.</font><br><br>24. What is hashing technique? Describe in brief.<br><br><font color="�#000000�"><u>Answer:</u><br>In general, in all searching techniques, search time is dependent on the number of items. Sequential search, binary search and all the search trees are totally dependent on number of items and many key comparisons are involved. Hashing is a technique where search time is independent of the number of items or elements. In this technique a hash function is used to generate an address from a key. The hash function takes a key as input and returns the hash value of that key which is used as an address index in the array. We can write hash function as follows h(k)=a; Where h is hash function, k is the key, a is the hash value of the key. While choosing a hash function we should consider some important points. It should be easy to compute It should generate address with minimum collision. What are different techniques for making hash function? Explain with example. Techniques for making hash function. Truncation Method Midsquare Method Folding Method Division Method Truncation Method This is the simplest method for computing address from a key.In this method we take only a part of the key as address. Example: Let us take some 8 digit keys and find addresses for them. Let the table size is 100 and we have to take 2 rightmost digits for getting the hash table address. Suppose the keys are. 62394572,87135565,93457271,45393225. So the address of above keys will be 72,65,71 and 25 respectively. This method is easy to compute but chances of collision are more because last two digits can be same in more than one keys. Midsquare Method In this method the key is squared and some digits from the middle of this square are taken as address. Example: Suppose that table size is 1000 and keys are as follows Key 1123 2273 3139 3045 Square of key 1261129 5166529 9853321 9272025 Address 612 665 533 720 Folding Method In this technique the key is divided into different part where the length of each part is same as that of the required address, except possibly the last part. Example: Let key is 123945234 and the table size is 1000 then we will broke this key as follows 123945234 > 123 945 234 Now we will add these broken parts. 123+945+234=1302. The sum is 1302, we will ignore the final carry 1, so the address for the key 123945234 is 302. Division Method (ModuloDivision) In ModuloDivision method the key is divided by the table size and the remainder is taken as the address of the hash table. Let the table size is n then H (k) =k mod n Example Let the keys are 123, 945,234 and table size is 11 then the address of these keys will be. 123 % 11=2 945%11=10 235%11=4 So the hash address of above keys will be 2,10,4. Note: Collisions can be minimized if the table size is taken to be a prime number.</font><br><br>25. What are different methods of collision resolution in hashing.<br><br><font color="�#000000�"><u>Answer:</u><br>A collision occurs whenever a key is mapped to an address that is already occupied. Collision Resolution technique provides an alternate place in hash table where this key can be placed. Collision Resolution technique can be classified as: 1) Open Addressing (Closed Hashing) a) Linear Probing b) Quadratic Probing c) Double Hashing 2) Separate Chaining (Open Hashing)</font><br><br>26. Describe Linear Probing with an example.<br><br><font color="�#000000�"><u>Answer:</u><br>In this method if address given by hash function is already occupied, then the key will be inserted in the next empty position in hash table. Let the table size is 7 and hash function returns address 4 for a key then we will search the empty location in this sequence. 4, 5, 6, 7, 0, 1, 2, 3 Example: Let the keys are 28, 47, 20, 36, 43, 23, 25, 54 and table size is 11 then</font><br><br>27. Describe the following term in a tree.<br><br><font color="�#000000�"><u>Answer:</u><br>a) Level b) Height c) Degree.</font><br><br>28. Describe binary tree and its property.<br><br><font color="�#000000�"><u>Answer:</u><br>In a binary tree a node can have maximum two children, or in other words we can say a node can have 0,1, or 2 children. Properties of binary tree. 1) The maximum number of nodes on any level i is 2i where i>=0. 2) The maximum number of nodes possible in a binary tree of height h is 2h1. 3) The minimum number of nodes possible in a binary tree of height h is equal to h. 4) If a binary tree contains n nodes then its maximum possible height is n and minimum height possible is log2 (n+1). 5) If n is the total no of nodes and e is the total no of edges then e=n1. The tree must be nonempty binary tree. 6) If n0 is the number of nodes with no child and n2 is the number of nodes with 2 children, then n0=n2+1.</font><br><br>29. Explain Extended Binary tree.<br><br><font color="�#000000�"><u>Answer:</u><br>A binarytree can be converted to an extended binary tree by adding special nodes to leaf nodes and nodes that have only one child.Extended binary tree is also called 2tree In the above figure external nodes are shown by squares and internal nodes by circles. The extended binary tree is a strictly binary tree means each node has either 0 or 2 children. The path length of any node is the number of edges traversed from that node to the root node. Internal path length of a binary tree is the sum of path lengths of all internal nodes and external path length of a binary tree is the sum of path lengths of all external nodes.</font><br><br>30. What are different dynamic memory allocation technique in C .<br><br><font color="�#000000�"><u>Answer:</u><br>The process of allocating memory at run time is called dynamic memory allocation. The allocation and release of this memory space can be done with the help of some predefined function. These functions allocate memory from a memory area called heap and free this memory whenever not required. The functions that are used to allocate memory at runtime are as follows: malloc() calloc() realloc() 1. malloc() This function allocates memory dynamically. It is generally used as: ptr= (datatype *) malloc(specified size); Here ptr is a pointer of type datatype ( can be int, float, double�.) and specified size is the size in bytes. The expression (datatype *) is used to typecast the pointer returned by malloc(). Example: int *ptr; ptr=(int *)malloc(4*sizeof(int)); It allocates the memory space to hold four integer values and the address of first byte is stored in the pointer variable ptr. The allocated memory contains garbage value. 2. calloc() The calloc() function is used to allocate multiple blocks of memory. Example: int *ptr; ptr=(int *)calloc(4, sizeof(int)); It allocates 4 blocks of memory and each block contains 2 bytes. 3. realloc() We can increase or decrease the memory allocated by malloc() or calloc() function. The realloc() function is used to change the size of the memory block. It changes the memory block without destroying the old data. Example: int *ptr; ptr=(int *)malloc(4*sizeof(int)); ptr=(int *)realloc(ptr,newsize); This function takes two argument, first is a pointer to the block of memory that was previously allocated by malloc() or calloc() and second argument is the new size of memory block. ptr=(int *)realloc(ptr, 4*sizeof(int)); // newsize</font><br><br><center><a href="2.html"><font color="#E60000">Previous</a>&nbsp;&nbsp;<a href="4.html"><font color="#E60000">Next</a></center></font></b></body></html>