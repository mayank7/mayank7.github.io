<html><body bgcolor="#0099CC"><b><font color="#FFFFFF" face="Verdana, Arial, Helvetica, sans-serif">181. How does an exception permeate through the code?<br><br><font color="�#000000�"><u>Answer:</u><br>An unhandled exception moves up the method stack in search of a matching When an exception is thrown from a code which is wrapped in a try block followed by one or more catch blocks, a search is made for matching catch block. If a matching type is found then that block will be invoked. If a matching type is not found then the exception moves up the method stack and reaches the caller method. Same procedure is repeated if the caller method is included in a try catch block. This process continues until a catch block handling the appropriate type of exception is found. If it does not find such a block then finally the program terminates.</font><br><br>182. What are the different ways to handle exceptions?<br><br><font color="�#000000�"><u>Answer:</u><br>There are two ways to handle exceptions, 1. By wrapping the desired code in a try block followed by a catch block to catch the exceptions. and 2. List the desired exceptions in the throws clause of the method and let the caller of the method hadle those exceptions.</font><br><br>183. Is it necessary that each try block must be followed by a catch block?<br><br><font color="�#000000�"><u>Answer:</u><br>It is not necessary that each try block must be followed by a catch block. It should be followed by either a catch block or a finally block. And whatever exceptions are likely to be thrown should be declared in the throws clause of the method.</font><br><br>184. If I write return at the end of the try block, will the finally block still execute?<br><br><font color="�#000000�"><u>Answer:</u><br>Yes even if you write return as the last statement in the try block and no exception occurs, the finally block will execute. The finally block will execute and then the control return.</font><br><br>185. If I write System.exit(0); at the end of the try block, will the finally block still execute?<br><br><font color="�#000000�"><u>Answer:</u><br>No. In this case the finally block will not execute because when you say System.exit(0); the control immediately goes out of the program, and thus finally never executes.</font><br><br>186. How are Observer and Observable used?<br><br><font color="�#000000�"><u>Answer:</u><br>Objects that subclass the Observable class maintain a list of observers. When an Observable object is updated it invokes the update() method of each of its observers to notify the observers that it has changed state. The Observer interface is implemented by objects that observe Observable objects.</font><br><br>187. What is synchronization and why is it important?<br><br><font color="�#000000�"><u>Answer:</u><br>With respect to multithreading, synchronization is the capability to control the access of multiple threads to shared resources. Without synchronization, it is possible for one thread to modify a shared object while another thread is in the process of using or updating that object's value. This often leads to significant errors.</font><br><br>188. How does Java handle integer overflows and underflows?<br><br><font color="�#000000�"><u>Answer:</u><br>It uses those low order bytes of the result that can fit into the size of the type allowed by the operation.</font><br><br>189. Does garbage collection guarantee that a program will not run out of memory?<br><br><font color="�#000000�"><u>Answer:</u><br>Garbage collection does not guarantee that a program will not run out of memory. It is possible for programs to use up memory resources faster than they are garbage collected. It is also possible for programs to create objects that are not subject to garbage collection.</font><br><br>190. What is the difference between preemptive scheduling and time slicing?<br><br><font color="�#000000�"><u>Answer:</u><br>Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.</font><br><br><center><a href="18.html"><font color="#E60000">Previous</a>&nbsp;&nbsp;<a href="20.html"><font color="#E60000">Next</a></center></font></b></body></html>